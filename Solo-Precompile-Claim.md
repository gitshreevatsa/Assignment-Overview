# Solo Precompile: Claiming Tokens from Cosmos Accounts

The Solo precompile is a built-in contract on Sei designed to let users claim all tokens from a Cosmos account and transfer them to an EVM account with a single, secure smart contract call. This streamlines asset migration and user onboarding for dApps and developers.

> **What is a precompile?**  
> A precompile is a special smart contract, deployed at a fixed address by the Sei protocol itself, that exposes custom native chain logic to EVM-based applications. It acts like a regular contract from the EVM’s perspective, but executes privileged, low-level logic efficiently, such as accessing native modules or performing advanced signature validation.

---

## How Does the Solo Precompile Work?

The Solo precompile at address `0x000000000000000000000000000000000000100C` exposes a `claim(bytes payload)` function.
- **Payload Generation:** Users generate a signed Cosmos claim transaction payload using the Sei CLI.
- **Contract Call:** Users submit this payload to the precompile via a contract call from their EVM account.
- **Token Migration:** The precompile verifies the payload and securely migrates all tokens from the Cosmos address to the EVM account.

---

## Use Cases

- **Token migration:** Move balances from Cosmos accounts to EVM accounts, e.g., during upgrades.
- **User onboarding:** Help users seamlessly transition from Cosmos wallets to EVM wallets.
- **Automation:** Enable dApps and scripts to programmatically migrate funds.

---

## Functions

The Solo precompile exposes the following function:

```solidity
/**
 * @dev Claim assets using approver's signed Cosmos tx payload.
 * @param payload Signed Cosmos tx payload as bytes.
 * @return response true indicates a successful claim.
 */
function claim(bytes memory payload) external returns (bool response);
```

- **claim(bytes payload):** Accepts a signed Cosmos transaction payload and, if valid, transfers all assets from the Cosmos account (sender) to the EVM account (caller).

---

## Step-by-Step Guide: Claiming Tokens Using the Solo Precompile

### Prerequisites

- Sei node RPC (devnet or mainnet)
- Node.js and Hardhat installed
- `seid` CLI available
- Access to the Sei Chain repo with this feature

**Creating a Cosmos Account:**

```sh
seid keys add solo
```
This creates a new Cosmos account named `solo`. You can view its address with:

```sh
seid keys show solo -a
```

---

### 2. Fund Your Cosmos Account (Testnet Only)

If you are on testnet, your Cosmos account will need tokens to pay for transactions.  
You can use the official Sei faucet to get testnet tokens:

- [Sei Testnet Faucet](https://www.docs.sei.io/learn/faucet)

Follow the instructions there to claim tokens for your Cosmos address.

---


### 3. Get Your EVM Account Address

Generate or use an existing EVM address from Hardhat, MetaMask, etc.

### 4. Generate the Claim Payload

```sh
seid tx evm print-claim <evm_address> --from solo -y
```

- Replace `<evm_address>` with your EVM wallet address.
- Save the hex-encoded output for the next step.

---

### 5. Call the Solo Precompile from JavaScript

Below is a minimal example using Ethers.js. You could run this as Hardhat tasks or a script to interact with the Solo precompile and claim your assets.
**Note:** The payload generated by the CLI is a hex string; you need to convert it to a `Uint8Array` for the contract call.  
Use the helper function `hex2uint8` as shown below:

```javascript
const { ethers } = require("hardhat");
const abi = require("../../precompiles/solo/abi.json");
const soloPrecompile = "0x000000000000000000000000000000000000100C";

// Helper to convert hex string to Uint8Array
function hex2uint8(hex) {
    const hex_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];
    hex = hex.toUpperCase();
    let uint8 = new Uint8Array(Math.floor(hex.length/2));
    for (let i=0; i < Math.floor(hex.length/2); i++) {
      uint8[i] = hex_chars.indexOf(hex[i*2])*16;
      uint8[i] += hex_chars.indexOf(hex[i*2+1]);
    }
    return uint8;
}

async function main() {
  const [signer] = await ethers.getSigners();

  // Use the payload generated from the CLI (hex string, without 0x)
  const hexPayload = "abcdef..."; // Paste your payload here (no 0x prefix)
  const payload = hex2uint8(hexPayload);

  const solo = new ethers.Contract(soloPrecompile, abi, signer);

  // Call the claim function
  const tx = await solo.claim(payload, { gasLimit: 100000 });
  const receipt = await tx.wait();

  if (receipt.status === 1) {
    console.log("Claim successful!");
  } else {
    console.log("Claim failed.");
  }
}

main().catch(console.error);
```

---

### 6. Verifying Assets on Your EVM Address

After a successful claim, your tokens will be available on your EVM account.  
To find the EVM asset contract address for your native Sei asset:

```sh
seid debug addr <native_asset_address>
```

- Replace `<native_asset_address>` with the address of the native token (for example, the denom address).
- The command will output the corresponding EVM address **(without the `0x` prefix)**.
- You can import this EVM address as a custom token in your EVM wallet (e.g., MetaMask) to see your balance.

---

## Troubleshooting

- **Gas issues:** Set gas limit to at least 100,000.
- **Invalid payload:** Always use the output from `seid tx evm print-claim ...`.
- **Sequence mismatch:** The Cosmos account must not make transactions after generating the payload.
- **Funding:** Ensure the Cosmos account is funded before claiming.

---

## Reference

- [Full E2E JavaScript Test Example (`SeiSoloTest.js`)](https://github.com/sei-protocol/sei-chain/blob/main/contracts/test/SeiSoloTest.js)  
  *(See this for a complete, automated test and for how to generate payloads and interact programmatically without using the CLI.)*
- [Pull Request: Add solo precompile for claim function](https://github.com/sei-protocol/sei-chain/pull/2129)
- [Sei Docs](https://docs.sei.io/)

---

## Thinking Process

This tutorial is based on [PR #2129](https://github.com/sei-protocol/sei-chain/pull/2129), which introduces the `claim()` method on the Solo precompile (`0x000...100C`). Since this functionality was not yet merged into the main branch or deployed to public networks (including devnet) at the time of writing, I could not test it in a live environment.

Given that precompiles are hardcoded into the node binary and not deployable as regular smart contracts, I studied the implementation in the PR and related CLI commands to infer expected behavior. I structured the tutorial to provide a developer-friendly, ready-to-test flow, including both CLI payload generation and contract interaction using Ethers.js. It follows Sei’s documentation style and the 30-3-30 approach to cater to skimmers, scanners, and deep readers alike.

## Limitations & Context

This documentation is based on features introduced in [PR #2129](https://github.com/sei-protocol/sei-chain/pull/2129), which were still open pull requests at the time of writing. These precompiles are not deployed on Sei devnet or mainnet, and as precompiles, they require node-level integration rather than smart contract deployment.

Due to the lack of public availability and the high hardware requirements for compiling and running a custom Sei node locally, the tutorials have not been executed end-to-end. Instead, they are based on code-level understanding, CLI reference, and expected usage patterns. The guides are written to be fully testable once the features are live.


## AI Assistance Disclosure
I used AI to assist me in drafting the docs in a more structured way after putting in my docs data of the PR. It helped me generate the reference links and helped me fetch the seid command for generating the evm address from the native asset address. I used ChatGPT 4 Turbo to help draft the readme and structure the report of my understanding of solo precompile and its related code snippets.